<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>技术总结 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="JVM    JVM预定义的三种类型类加载器        启动（Bootstrap）类加载器            是用本地代码实现的类装入器，它负责将 &#x2F;lib下面的类库加载到内存中（比如rt.jar）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。        标准扩展（Extension）类加载器">
<meta property="og:type" content="website">
<meta property="og:title" content="技术总结">
<meta property="og:url" content="http://example.com/%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="JVM    JVM预定义的三种类型类加载器        启动（Bootstrap）类加载器            是用本地代码实现的类装入器，它负责将 &#x2F;lib下面的类库加载到内存中（比如rt.jar）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。        标准扩展（Extension）类加载器">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-06-10T07:54:36.000Z">
<meta property="article:modified_time" content="2021-06-10T07:54:53.552Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="page-" class="h-entry article article-type-page" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93.html" class="article-date">
  <time class="dt-published" datetime="2021-06-10T07:54:36.000Z" itemprop="datePublished">2021-06-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      技术总结
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>JVM<br>    JVM预定义的三种类型类加载器<br>        启动（Bootstrap）类加载器<br>            是用本地代码实现的类装入器，它负责将 <Java_Runtime_Home>/lib下面的类库加载到内存中（比如rt.jar）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。<br>        标准扩展（Extension）类加载器<br>            是由 Sun 的 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将&lt; Java_Runtime_Home &gt;/lib/ext或者由系统变量 java.ext.dir指定位置中的类库加载到内存中。开发者可以直接使用标准扩展类加载器。<br>        系统（System）类加载器<br>            是由 Sun 的 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。它负责将系统类路径（CLASSPATH）中指定的类库加载到内存中。开发者可以直接使用系统类加载器<br>        除了以上列举的三种类加载器，还有一种比较特殊的类型 — 线程上下文类加载器。<br>    双亲委派机制<br>        描述<br>            某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。<br>        意义<br>            防止内存中出现多份同样的字节码<br>                比如两个类A和类B都要加载System类：<br>                如果不用委托而是自己加载自己的，那么类A就会加载一份System字节码，然后类B又会加载一份System字节码，这样内存中就出现了两份System字节码。<br>                如果使用委托机制，会递归的向父类查找，也就是首选用Bootstrap尝试加载，如果找不到再向下。这里的System就能在Bootstrap中找到然后加载，如果此时类B也要加载System，也从Bootstrap开始，此时Bootstrap发现已经加载过了System那么直接返回内存中的System即可而不需要重新加载，这样内存中就只有一份System的字节码了。<br>        具体含义<br>            当Java虚拟机要加载一个类时，到底派出哪个类加载器去加载呢？<br>            首先当前线程的类加载器去加载线程中的第一个类（假设为类A）。<br>            注：当前线程的类加载器可以通过Thread类的getContextClassLoader()获得，也可以通过setContextClassLoader()自己设置类加载器。<br>            如果类A中引用了类B，Java虚拟机将使用加载类A的类加载器去加载类B。<br>            还可以直接调用ClassLoader.loadClass()方法来指定某个类加载器去加载某个类。<br>    思考<br>        Java虚拟机的第一个类加载器是Bootstrap，这个加载器很特殊，它不是Java类，因此它不需要被别人加载，它嵌套在Java虚拟机内核里面，也就是JVM启动的时候Bootstrap就已经启动，它是用C++写的二进制代码（不是字节码），它可以去加载别的类。这也是我们在测试时为什么发现System.class.getClassLoader()结果为null的原因，这并不表示System这个类没有类加载器，而是它的加载器比较特殊，是BootstrapClassLoader，由于它不是Java类，因此获得它的引用肯定返回null。</p>
<p>类锁与对象锁区别<br>    1. 如果多线程同时访问同一类的 类锁（synchronized 修饰的静态方法）以及对象锁（synchronized 修饰的非静态方法）这两个方法执行是异步的，原因：类锁和对象锁是2中不同的锁。<br>    2. 类锁对该类的所有对象都能起作用，而对象锁不能。</p>
<p>值传递和引用传递<br>    值传递和引用传递的本质区别在于是否在传递的时候进行对象的内存拷贝。<br>    基本类型是由于在JVM中存储区域不同于普通对象所以传递前会拷贝，传递的是拷贝后的值，但是对象在传递的时候不拷贝，直接传“引用值”，指向同一片对象堆内存区域，当然要注意String这种特殊情况。</p>
<p>servlet的生命周期<br>    Servlet有三个生命周期函数，初始化方法init(),处理客户请求的方法service(),终止方法destroy()。</p>
<p>cookie和session<br>    Cookie与Session都是用来跟踪浏览器用户身份的会话方式。<br>    区别：<br>        Cookie数据存放在客户的浏览器上，Session数据放在服务器上。<br>        Cookie不是很安全，别人可以分析存放在本地的Cookie并进行Cookie欺骗,如果主要考虑到安全应当使用加密的Cookie或者Session。<br>        Session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，如果主要考虑到减轻服务器性能方面，应当使用Cookie。<br>        单个Cookie在客户端的限制是4K，很多浏览器都限制一个站点最多保存20个Cookie。</p>
<p>四种引用<br>    强引用<br>        强引用就是指在程序代码之中普遍存在的，类似”Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。<br>            Object obj = new Object();<br>    软引用<br>        软引用是用来描述一些还有用但并非必需的对象，对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK1.2之后，提供了SoftReference类来实现软引用。<br>            Object obj = new Object();<br>            SoftReference<Object> sf = new SoftReference<Object>(obj);<br>    弱引用<br>        弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象，只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2之后，提供了WeakReference类来实现弱引用<br>            Object obj = new Object();<br>            WeakReference<Object> wf = new WeakReference<Object>(obj);<br>    虚引用<br>        虚引用也成为幽灵引用或者幻影引用，它是最弱的一中引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在JDK1.2之后，提供给了PhantomReference类来实现虚引用。<br>            Object obj = new Object();<br>            PhantomReference<Object> pf = new PhantomReference<Object>(obj);</p>
<p>反射<br>    在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。<br>    反射的核心是JVM在运行时才动态加载类或调用方法/访问属性，它不需要事先知道运行对象是谁。</p>
<p>lambda表达式<br>    Function–&gt;apply()</p>
<p>消息<br>    eventBus<br>    metaq<br>    notify</p>
<p>java<br>    guava<br>        Function函数式编程<br>        HashBasedTable<br>        eventBus<br>    Assert.notNull(rq, “rq cannot be null”);<br>    Validate.notNull()<br>    org.apache.commons.lang3.tuple.Pair<br>    BeanPostProcessor</p>
<p>zookeeper<br>    Zab一致性协议<br>        ZAB原子消息广播协议<br>        节点之间的一致性算法为Paxos<br>    应用场景<br>        数据发布与订阅（配置中心）<br>        负载均衡<br>        命名服务(Naming Service)<br>        分布式通知/协调<br>        集群管理与Master选举<br>        分布式锁<br>        分布式队列<br>    应用<br>        统一命名服务（NameService）<br>        配置管理（ConfigurationManagement）<br>        集群管理（GroupMembership）<br>        共享锁（Locks）<br>        队列管理<br>    写数据流程<br>        Client向zk的server1上写数据，发送一个写的请求。<br>        如果server1不是leader,那么server1会把接收的请求转发给leader。这个leader会将写请求广播给各个server，比如server1和server2,各个server写成功之后就会通知leader。<br>        当leader收到大多数server写成功的消息，那么就说明数据写成功了。之后leader会告诉server1数据写成功了。<br>        server1会通知Client数据写成功了。这时就认为整个写操作成功。<br>    master选举</p>
<p>线程<br>    FutureTask<br>        Future<br>    ThreadPoolExecutor<br>        Callable<br>        Thread<br>    实现线程同步<br>    ReentrantReadWriteLock多线程读写锁<br>    两类线程<br>        用户线程 (User Thread)<br>        守护线程 (Daemon Thread)<br>            指在程序运行的时候在后台提供一种通用服务的线程，比如垃圾回收线程<br>            为什么要用守护线程？<br>                静态变量是ClassLoader级别的，如果Web应用程序停止，这些静态变量也会从JVM中清除。但是线程则是JVM级别的，如果你在Web 应用中启动一个线程，这个线程的生命周期并不会和Web应用程序保持同步。也就是说，即使你停止了Web应用，这个线程依旧是活跃的<br>    CAS机制运用AtomicLong原子操作类<br>        原子变量<br>    1. java语言CAS底层如何实现？<br>        利用unsafe提供的原子性操作方法。AtomicLong<br>    2.什么事ABA问题？怎么解决？<br>        当一个值从A变成B，又更新回A，普通CAS机制会误判通过检测。<br>        利用版本号比较可以有效解决ABA问题。<br>         AtomicStampedReference和 AtomicMarkableReference是通过版本号（时间戳）来解决ABA问题的，我们也可以使用版本号（verison）来解决ABA。<br>        即乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1操作，否则就执行失败。<br>    乐观锁常见的两种实现方式<br>        乐观锁一般会使用版本号机制或CAS算法实现。（适用于多读场景）<br>         CAS是compare and swap，翻译过来就是比较并交换。维护三个变量值，一个是内存值V，一个是期望的旧的值A，一个是要更新的值B。更新一个变量的时候，只有当预期值A与内存V中的值相等的时候，才会执行更新操作，把内存V的值改为B。<br>    悲观锁<br>        Java中synchronized和ReentrantLock等独占锁<br>        关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁<br>    单独调用interrupt()方法不能中断正在运行过程中的线程，只能中断阻塞过程中的线程。 </p>
<p>sql</p>
<p>状态机</p>
<p>缓存<br>    redis<br>    缓存世界中的三大问题及解决方案<br>        1. 缓存穿透<br>             缓存空数据<br>            BloomFilter:在缓存之前再加一道屏障，里面存储目前数据库中存在的所有key<br>        缓存雪崩<br>        缓存击穿(热点数据集中失效)<br>            设置不同的失效时间<br>    缓存的应用：网站访问数据的特点大多数呈现在”二八定律”:80%的业务访问集中在20%的数据上。这时为了减轻数据的压力和提高网站的数据访问速度，则可以使用缓存机制来优化网站。</p>
<p>redis<br>    命令<br>        String（字符串）<br>            string类型是二进制安全的<br>                GET name “redis.net.cn”<br>                SET name “redis.net.cn”<br>        Hash（哈希）<br>            Redis hash 是一个键值对集合。<br>                 HMSET userTestSet username xiaoming password 111<br>                HGETALL userTestSet<br>        List（列表）<br>            Redis 列表是简单的字符串列表，按照插入顺序排序<br>                lpush redis.net.cn redis<br>                lrange redis.net.cn 0 10<br>        Set（集合）<br>            Redis的Set是string类型的无序集合,值不会重复<br>                sadd redis.net.cn redis<br>                smembers redis.net.cn<br>        zset(sorted set：有序集合)<br>             zadd redis.net.cn 0 redis<br>            ZRANGEBYSCORE redis.net.cn 0 1000<br>    应用场景<br>        缓存<br>        消息队列<br>        时间轴（Timeline）<br>        排行榜<br>        计数器<br>        好友关系<br>        分布式锁<br>        倒排索引<br>    redis的插槽分配机制就是一个负载均衡的模式（数据分片）<br>        HASH_SLOT（key）= CRC16(key) % 16384<br>    Redis中可以使用轮询策略以及redis底层提供的CAS原语(如setnx)<br>    总结<br>        Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。<br>        Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。<br>        Redis支持数据的备份，即master-slave模式的数据备份。<br>    Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。<br>    redis的过期机制<br>        惰性删除+定期删除<br>            惰性删除<br>                在进行get或set等操作时，先检查key是否过期，<br>                若过期，删除key，然后执行相应操作；<br>                若没过期，直接执行相应操作<br>            定期删除<br>                遍历每个数据库（就是redis.conf中配置的”database”数量，默认为16）<br>                检查当前库中的指定个数个key（默认是每个库检查20个key，注意相当于该循环执行20次，循环体时下边的描述）<br>                如果当前库中没有一个key设置了过期时间，直接执行下一个库的遍历<br>                随机获取一个设置了过期时间的key，检查该key是否过期，如果过期，删除key<br>                判断定期删除操作是否已经达到指定时长，若已经达到，直接退出定期删除。<br>    为什么这么快<br>        1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；<br>        2、数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；<br>        3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；<br>        4、使用多路I/O复用模型，非阻塞IO；<br>        5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；<br>    内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间<br>    Redis 内置了复制（Replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（Transactions） 和不同级别的磁盘持久化（Persistence），并通过 Redis哨兵（Sentinel）和自动分区（Cluster）提供高可用性（High Availability）。</p>
<p>metaq与notify对比</p>
<p>git</p>
<p>代理<br>    JDK原生动态代理<br>        实现InvocationHandler<br>    CGLIB动态代理<br>        CGLIB(Code Generation Library)是一个基于ASM的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB通过继承方式实现代理。<br>            Enhancer<br>            实现MethodInterceptor<br>            实现CallbackFilter </p>
<p>一致性hash算法<br>    m = hash(o) mod n ——式子1<br>    一致性hash算法解决了分布式环境下机器增加或者减少时，简单的取模运算无法获取较高命中率的问题。通过虚拟节点的使用，一致性hash算法可以均匀分担机器的负载，使得这一算法更具现实的意义。正因如此，一致性hash算法被广泛应用于分布式系统中。<br>    引入虚拟节点来解决负载不均衡的问题</p>
<p>负载均衡分发策略<br>    负载均衡算法<br>        Ø  轮询（RoundRobin）将请求顺序循环地发到每个服务器。当其中某个服务器发生故障，AX就把其从顺序循环队列中拿出，不参加下一次的轮询，直到其恢复正常。<br>        Ø  比率（Ratio）：给每个服务器分配一个加权值为比例，根椐这个比例，把用户的请求分配到每个服务器。当其中某个服务器发生故障，AX就把其从服务器队列中拿出，不参加下一次的用户请求的分配，直到其恢复正常。<br>        Ø  优先权（Priority）：给所有服务器分组，给每个组定义优先权，将用户的请求分配给优先级最高的服务器组（在同一组内，采用预先设定的轮询或比率算法，分配用户的请求）；当最高优先级中所有服务器或者指定数量的服务器出现故障，AX将把请求送给次优先级的服务器组。这种方式，实际为用户提供一种热备份的方式。<br>        Ø  最少连接数（LeastConnection）：AX会记录当前每台服务器或者服务端口上的连接数，新的连接将传递给连接数最少的服务器。当其中某个服务器发生故障，AX就把其从服务器队列中拿出，不参加下一次的用户请求的分配，直到其恢复正常。<br>        Ø  最快响应时间（Fast Reponse time）：新的连接传递给那些响应最快的服务器。当其中某个服务器发生故障，AX就把其从服务器队列中拿出，不参加下一次的用户请求的分配，直到其恢复正常。<br>    其他算法<br>        Ø  哈希算法( hash):  将客户端的源地址，端口进行哈希运算，根据运算的结果转发给一台服务器进行处理，当其中某个服务器发生故障，就把其从服务器队列中拿出，不参加下一次的用户请求的分配，直到其恢复正常。<br>        Ø  基于策略的负载均衡：针对不同的数据流设置导向规则，用户可自行编辑流量分配策略，利用这些策略对通过的数据流实施导向控制。<br>        Ø  基于数据包的内容分发：例如判断HTTP的URL，如果URL中带有.jpg的扩展名，就把数据包转发到指定的服务器。</p>
<p>引用<br>    虚拟机栈中的本地变量表中存储的数值代表的是另一块内存的地址，就称另一块块内存被引用。但是现在区分远比以前要严谨的多，主要分为以下四种引用类型：①强引用；②软引用；③弱引用；④虚引用。强引用就是永远不会回收掉被引用的对象，比如说我们代码中new出来的对象。软引用表示有用但是非必需的，如果系统内存资源紧张，可能就会被回收；弱引用表示非必需的对象，只能存活到下一次垃圾回收发生之前；虚引用是最弱的，这个引用无法操作对象。</p>
<p>数据库中字段定义</p>
<p>查找算法<br>    顺序、二分、hash</p>
<p>系统中为什么要用消息中间件<br>    1）系统解耦<br>    2）异步调用<br>    3）流量削峰</p>
<p>nio<br>    NIO 是一种同步非阻塞的 IO 模型。<br>    同步是指线程不断轮询 IO 事件是否就绪<br>    非阻塞是指线程在等待 IO 的时候，可以同时做其他任务。<br>    同步的核心就是 Selector，Selector 代替了线程本身轮询 IO 事件，避免了阻塞同时减少了不必要的线程消耗；<br>    非阻塞的核心就是通道和缓冲区，当 IO 事件就绪时，可以通过写道缓冲区，保证 IO 的成功，而无需线程阻塞式地等待。<br>    基于阻塞式I/O的多线程模型中，Server为每个Client连接创建一个处理线程，每个处理线程阻塞式等待可能达到的数据，一旦数据到达，则立即处理请求、返回处理结果并再次进入等待状态。</p>
<p>aop<br>    AOP应用：事务、缓存、日志、性能等<br>    使用spring的声明式事务后，只需要在数据库处理方法上注解事务，就可以对操作进行管理，事务的设置和逻辑代码分开，<br>        　1、Aspect（切面） ： 应用运行过程中的关注点，关注点可以横切多个对象，被称为横切关注点。<br>        　　2、pointcut（切入点）：可插入增强处理的连接点。<br>        　　3、joinpoint（连接点）：程序执行过程中明确的点，如方法的调用，或者异常的抛出。<br>        　　4、advice（增强处理）：AOP框架特定的切入点执行的增强处理<br>    在AOP编程，我们需要做如下三部分：<br>        　　1、定义普通组件。<br>        　　2、定义切入点、一个切入点可能横切多个业务组件。<br>        　　3、定义增强处理，增强处理就是在AOP框架为普通业务组件织入的处理动作。</p>
<p>spingmvc<br>    1、用户发送请求至前端控制器DispatcherServlet<br>    2、DispatcherServlet收到请求调用HandlerMapping处理器映射器。<br>    3、处理器映射器找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。执行链（HandlerExecutionChain包含处理器对象及处理器拦截器）<br>    4、DispatcherServlet调用HandlerAdapter处理器适配器<br>    5、HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。<br>    6、Controller执行完成返回ModelAndView<br>    7、HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet<br>    8、DispatcherServlet将ModelAndView传给ViewReslover视图解析器<br>    9、ViewReslover解析后返回具体View<br>    10、DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。<br>    11、DispatcherServlet响应用户</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93.html" data-id="ckpqlyz0a00006exfcdzu2900" data-title="技术总结" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/06/10/redis%E9%9D%A2%E8%AF%95%E9%A2%98/">redis面试题</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>